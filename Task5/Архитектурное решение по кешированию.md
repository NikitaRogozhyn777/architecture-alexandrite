# Задание 5. Архитектурное решение по логированию

## Мотивация внедрения кеширования
Основная проблема «Александрита» — растущие задержки в обработке заказов и недовольство клиентов из-за долгой загрузки интерфейсов, особенно в MES. Это напрямую влияет на бизнес: теряются контракты, увеличивается нагрузка на операторов, а задержки в CRM и MES приводят к хаосу в управлении заказами. Внедрение кеширования поможет снизить нагрузку на базы данных и ускорить отклик системы, особенно для часто запрашиваемых данных, таких как списки заказов, статусы и расчётные стоимости.

Кеширование стоит применить в нескольких ключевых точках:

- Дашборд заказов в MES — закешировать списки заказов с пагинацией и фильтрами, чтобы операторы мгновенно получали актуальные данные без постоянных запросов к БД.
- Расчёт стоимости в MES — кешировать результаты для похожих 3D-моделей, чтобы избежать повторных долгих вычислений.
- API для партнёров — кешировать ответы на часто повторяющиеся запросы, снижая нагрузку на систему при массовом создании заказов.

Это не только ускорит работу системы, но и разгрузит базы данных, уменьшит время отклика для пользователей и поможет справиться с растущим потоком заказов без масштабных изменений инфраструктуры. В долгосрочной перспективе это повысит удовлетворённость клиентов и снизит риски потери контрактов.

## Предлагаемое решение

Для повышения производительности и отзывчивости системы предлагается внедрение серверного кеширования в ключевых компонентах архитектуры. Клиентское кеширование (например, в браузере или мобильном приложении) не решит проблему полностью, так как основные задержки связаны с обработкой данных на сервере (особенно в MES и CRM).

### 1. Кеширование списка заказов в MES (Cache-Aside)
**Проблема**: Дашборд MES долго загружается из-за частых запросов к БД, особенно при фильтрации и пагинации.
**Решение**: Внедрить Cache-Aside с использованием Redis.

**Преимущества Cache-Aside**:
- Заказы часто читаются, но редко обновляются (статусы меняются не так часто).
- Данные загружаются в кеш только при первом запросе, снижая нагрузку на БД.
- Проще контролировать согласованность данных (инвалидация кеша при изменении статусов).

**Почему не другие стратегии?**
- **Write-Through**: Увеличивает нагрузку на запись, а в MES статусы меняются редко.
- **Write-Behind**: Усложняет логику и требует надежной очереди, что избыточно для данной задачи.

### 2. Кеширование результатов расчёта стоимости в MES
**Проблема**: Расчёт стоимости занимает 2–30 минут, особенно для сложных моделей.
**Решение**: Кеширование по хешу 3D-модели (например, MD5 от файла).

- Если модель уже рассчитывалась, возвращать результат из кеша.

**Почему не Refresh-Ahead?**
- Refresh-Ahead требует предсказуемости запросов, а здесь они динамические.
- Cache-Aside проще и эффективнее для редких, но ресурсоемких операций.


### 3. Кеширование API для партнёров (Write-Through + TTL)
**Проблема**: Массовые запросы от партнёров перегружают систему.
**Решение**:

- **Для чтения**: Cache-Aside с TTL (например, 1 минута для актуальности).
- **Для записи (создания заказов)**: Write-Through, чтобы сразу сохранять данные в кеш и БД, избегая расхождений.

**Почему Write-Through?**
- Заказы критичны, и их потеря недопустима.
- Гарантирует согласованность между кешем и БД.

### SD Диаграмма
![SD Диаграмма](./SD%20Диаграмма.png)


### 4. Стратегия инвалидации кеша

Для эффективного кеширования в MES предлагается комбинированная стратегия инвалидации, сочетающая:
- **Инвалидацию по ключу** (при изменении данных)
- **TTL** (временную инвалидацию для устаревающих данных)

#### Сравнение стратегий

| Стратегия          | Плюсы                                      | Минусы                                     | Применимость                               |
|--------------------|--------------------------------------------|--------------------------------------------|--------------------------------------------|
| **Инвалидация по ключу** | Гарантирует актуальность при изменениях | Требует явного управления ключами         | Подходит - заказы меняются редко, но важно обновлять кеш при изменении статуса |
| **TTL**            | Автоматически очищает старые данные        | Риск показа устаревших данных до истечения | Подходит - для списков заказов, где задержка 60 сек допустима |
| **Write-Through**  | Кеш всегда актуален                       | Высокая нагрузка на запись                | Не подходит - избыточно для редко меняющихся статусов |
| **Refresh-Ahead**  | Предзагружает данные до истечения TTL     | Сложная реализация, избыточность          | Не подходит - нет четкой периодичности запросов |

#### Детализация реализации

##### Для списков заказов (дашборд MES)
- **TTL = 60 сек** - оптимальный баланс между актуальностью и нагрузкой
- **Инвалидация по ключу** при изменении статуса (удаление ключей `orders:*`)

##### Для расчета стоимости
- Кеширование по хешу модели
- **TTL = 24 часа** (данные редко изменяются)

##### Для API партнеров
- **Write-Through + TTL** - гарантия согласованности при массовых заказах

#### Почему не другие подходы?
- **Только TTL**: Риск показа устаревших статусов
- **Только инвалидация по ключу**: Не защищает от "зависших" данных
